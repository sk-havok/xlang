// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#pragma once
#include "winrt/impl/Component.2.h"
namespace winrt::impl
{
    template <typename D> hstring consume_Component_IClass<D>::Method() const
    {
        void* result;
        check_hresult(WINRT_SHIM(Component::IClass)->Method(&result));
        return { construct_from_abi, result };
    }
    template <typename D> hstring consume_Component_IClass<D>::Property() const
    {
        void* value;
        check_hresult(WINRT_SHIM(Component::IClass)->get_Property(&value));
        return { construct_from_abi, value };
    }
    template <typename D> void consume_Component_IClass<D>::Property(param::hstring const& value) const
    {
        check_hresult(WINRT_SHIM(Component::IClass)->put_Property(get_abi(value)));
    }
    template <typename D> Component::Class consume_Component_IClassFactory<D>::CreateInstance(param::hstring const& a) const
    {
        void* value;
        check_hresult(WINRT_SHIM(Component::IClassFactory)->CreateInstance(get_abi(a), &value));
        return { construct_from_abi, value };
    }
    template <typename D> hstring consume_Component_IClassStatics<D>::StaticMethod() const
    {
        void* result;
        check_hresult(WINRT_SHIM(Component::IClassStatics)->StaticMethod(&result));
        return { construct_from_abi, result };
    }
    template <typename D> hstring consume_Component_Class<D>::Method(Component::Class const& winrt_impl_this) const
    {
        void* result;
        check_hresult(WINRT_SHIM(fast_factory<Component::Class>)->Method(get_abi(winrt_impl_this), &result));
        return { construct_from_abi, result };
    }
    template <typename D> hstring consume_Component_Class<D>::Property(Component::Class const& winrt_impl_this) const
    {
        void* value;
        check_hresult(WINRT_SHIM(fast_factory<Component::Class>)->get_Property(get_abi(winrt_impl_this), &value));
        return { construct_from_abi, value };
    }
    template <typename D> void consume_Component_Class<D>::Property(Component::Class const& winrt_impl_this, param::hstring const& value) const
    {
        check_hresult(WINRT_SHIM(fast_factory<Component::Class>)->put_Property(get_abi(winrt_impl_this), get_abi(value)));
    }
    template <typename D> Component::Class consume_Component_Class<D>::CreateInstance(param::hstring const& a) const
    {
        void* value;
        check_hresult(WINRT_SHIM(fast_factory<Component::Class>)->CreateInstance(get_abi(a), &value));
        return { construct_from_abi, value };
    }
    template <typename D> hstring consume_Component_Class<D>::StaticMethod() const
    {
        void* result;
        check_hresult(WINRT_SHIM(fast_factory<Component::Class>)->StaticMethod(&result));
        return { construct_from_abi, result };
    }
    template <> struct delegate<Component::Delegate>
    {
        template <typename H>
        struct type : implements_delegate<Component::Delegate, H>
        {
            type(H&& handler) : implements_delegate<Component::Delegate, H>(std::forward<H>(handler)) {}

            int32_t WINRT_CALL Invoke(void* arg) noexcept final
            {
                try
                {
                    (*this)(*reinterpret_cast<hstring const*>(&arg));
                    return 0;
                }
                catch (...)
                {
                    return to_hresult();
                }
            }
        };
    };
    template <typename D>
    struct produce<D, Component::IClass> : produce_base<D, Component::IClass>
    {
        int32_t WINRT_CALL Method(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Method, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().Method());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL get_Property(void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Property, WINRT_WRAP(hstring));
                *value = detach_from<hstring>(this->shim().Property());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL put_Property(void* value) noexcept final
        {
            try
            {
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Property, WINRT_WRAP(void), hstring const&);
                this->shim().Property(*reinterpret_cast<hstring const*>(&value));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, Component::IClassFactory> : produce_base<D, Component::IClassFactory>
    {
        int32_t WINRT_CALL CreateInstance(void* a, void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(Component::Class), hstring const&);
                *value = detach_from<Component::Class>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&a)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, Component::IClassStatics> : produce_base<D, Component::IClassStatics>
    {
        int32_t WINRT_CALL StaticMethod(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(StaticMethod, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().StaticMethod());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, fast_factory<Component::Class>> : produce_base<D, fast_factory<Component::Class>>
    {
        int32_t WINRT_CALL ActivateInstance(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(ActivateInstance, WINRT_WRAP(Component::Class));
                *result = detach_abi(this->shim().ActivateInstance());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL Method(void* winrt_impl_this, void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Method, WINRT_WRAP(hstring), Component::Class const&);
                *result = detach_from<hstring>(this->shim().Method(*reinterpret_cast<Component::Class const*>(&winrt_impl_this)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL get_Property(void* winrt_impl_this, void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Property, WINRT_WRAP(hstring), Component::Class const&);
                *value = detach_from<hstring>(this->shim().Property(*reinterpret_cast<Component::Class const*>(&winrt_impl_this)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL put_Property(void* winrt_impl_this, void* value) noexcept final
        {
            try
            {
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Property, WINRT_WRAP(void), Component::Class const&, hstring const&);
                this->shim().Property(*reinterpret_cast<Component::Class const*>(&winrt_impl_this), *reinterpret_cast<hstring const*>(&value));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL CreateInstance(void* a, void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(Component::Class), hstring const&);
                *value = detach_from<Component::Class>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&a)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL StaticMethod(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(StaticMethod, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().StaticMethod());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
}
namespace winrt::Component
{
    template <typename L> Delegate::Delegate(L handler) :
        Delegate(impl::make_delegate<Delegate>(std::forward<L>(handler)))
    {}

    template <typename F> Delegate::Delegate(F* handler) :
        Delegate([=](auto&&... args) { return handler(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(O* object, M method) :
        Delegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(com_ptr<O>&& object, M method) :
        Delegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(weak_ref<O>&& object, M method) :
        Delegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {}

    inline void Delegate::operator()(param::hstring const& arg) const
    {
        check_hresult((*(impl::abi_t<Delegate>**)this)->Invoke(get_abi(arg)));
    }
}
namespace std
{
    template<> struct hash<winrt::Component::IClass> : winrt::impl::hash_base<winrt::Component::IClass> {};
    template<> struct hash<winrt::Component::IClassFactory> : winrt::impl::hash_base<winrt::Component::IClassFactory> {};
    template<> struct hash<winrt::Component::IClassStatics> : winrt::impl::hash_base<winrt::Component::IClassStatics> {};
    template<> struct hash<winrt::Component::Class> : winrt::impl::hash_base<winrt::Component::Class> {};
}
