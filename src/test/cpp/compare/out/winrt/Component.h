// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#pragma once
#include "winrt/impl/Component.2.h"
namespace winrt::impl
{
    template <typename D> Component::Class consume_Component_IClass<D>::ReturnObject() const
    {
        void* result;
        check_hresult(WINRT_SHIM(Component::IClass)->ReturnObject(&result));
        return { construct_from_abi, result };
    }
    template <typename D> hstring consume_Component_IClass<D>::Method() const
    {
        void* result;
        check_hresult(WINRT_SHIM(Component::IClass)->Method(&result));
        return { construct_from_abi, result };
    }
    template <typename D> hstring consume_Component_IClass<D>::Property() const
    {
        void* value;
        check_hresult(WINRT_SHIM(Component::IClass)->get_Property(&value));
        return { construct_from_abi, value };
    }
    template <typename D> void consume_Component_IClass<D>::Property(param::hstring const& value) const
    {
        check_hresult(WINRT_SHIM(Component::IClass)->put_Property(get_abi(value)));
    }
    template <typename D> Component::Class consume_Component_IClassFactory<D>::CreateInstance(param::hstring const& a) const
    {
        void* value;
        check_hresult(WINRT_SHIM(Component::IClassFactory)->CreateInstance(get_abi(a), &value));
        return { construct_from_abi, value };
    }
    template <typename D> hstring consume_Component_IClassStatics<D>::StaticMethod() const
    {
        void* result;
        check_hresult(WINRT_SHIM(Component::IClassStatics)->StaticMethod(&result));
        return { construct_from_abi, result };
    }
    template <> struct delegate<Component::Delegate>
    {
        template <typename H>
        struct type : implements_delegate<Component::Delegate, H>
        {
            type(H&& handler) : implements_delegate<Component::Delegate, H>(std::forward<H>(handler)) {}

            int32_t WINRT_CALL Invoke(void* arg) noexcept final
            {
                try
                {
                    (*this)(*reinterpret_cast<hstring const*>(&arg));
                    return 0;
                }
                catch (...)
                {
                    return to_hresult();
                }
            }
        };
    };
    template <typename D>
    struct produce<D, Component::IClass> : produce_base<D, Component::IClass>
    {
        int32_t WINRT_CALL ReturnObject(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(ReturnObject, WINRT_WRAP(Component::Class));
                *result = detach_from<Component::Class>(this->shim().ReturnObject());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL Method(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Method, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().Method());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL get_Property(void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Property, WINRT_WRAP(hstring));
                *value = detach_from<hstring>(this->shim().Property());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL put_Property(void* value) noexcept final
        {
            try
            {
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Property, WINRT_WRAP(void), hstring const&);
                this->shim().Property(*reinterpret_cast<hstring const*>(&value));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, Component::IClassFactory> : produce_base<D, Component::IClassFactory>
    {
        int32_t WINRT_CALL CreateInstance(void* a, void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(Component::Class), hstring const&);
                *value = detach_from<Component::Class>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&a)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, Component::IClassStatics> : produce_base<D, Component::IClassStatics>
    {
        int32_t WINRT_CALL StaticMethod(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(StaticMethod, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().StaticMethod());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
}
namespace winrt::Component
{
inline hstring Class::StaticMethod()
{
    return impl::call_factory<Class, Component::IClassStatics>([&](auto&& f) { return f.StaticMethod(); });
}
inline Class::Class(param::hstring const& a) :
    Class(impl::call_factory<Class, Component::IClassFactory>([&](auto&& f) { return f.CreateInstance(a); }))
{}
inline Class::Class() :
    Class(impl::call_factory<Class>([](auto&& f) { return f.template ActivateInstance<Class>(); }))
{}
    template <typename L> Delegate::Delegate(L handler) :
        Delegate(impl::make_delegate<Delegate>(std::forward<L>(handler)))
    {}

    template <typename F> Delegate::Delegate(F* handler) :
        Delegate([=](auto&&... args) { return handler(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(O* object, M method) :
        Delegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(com_ptr<O>&& object, M method) :
        Delegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(weak_ref<O>&& object, M method) :
        Delegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {}

    inline void Delegate::operator()(param::hstring const& arg) const
    {
        check_hresult((*(impl::abi_t<Delegate>**)this)->Invoke(get_abi(arg)));
    }
}
namespace std
{
    template<> struct hash<winrt::Component::IClass> : winrt::impl::hash_base<winrt::Component::IClass> {};
    template<> struct hash<winrt::Component::IClassFactory> : winrt::impl::hash_base<winrt::Component::IClassFactory> {};
    template<> struct hash<winrt::Component::IClassStatics> : winrt::impl::hash_base<winrt::Component::IClassStatics> {};
    template<> struct hash<winrt::Component::Class> : winrt::impl::hash_base<winrt::Component::Class> {};
}
