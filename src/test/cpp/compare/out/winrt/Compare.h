// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#pragma once
#include "winrt/impl/Compare.2.h"
namespace winrt::impl
{
    template <typename D> hstring consume_Compare_IClass<D>::Method() const
    {
        void* result;
        check_hresult(WINRT_SHIM(Compare::IClass)->Method(&result));
        return { construct_from_abi, result };
    }
    template <typename D> Compare::Class consume_Compare_IClassFactory<D>::CreateInstance(param::hstring const& a) const
    {
        void* value;
        check_hresult(WINRT_SHIM(Compare::IClassFactory)->CreateInstance(get_abi(a), &value));
        return { construct_from_abi, value };
    }
    template <typename D> hstring consume_Compare_IClassStatics<D>::StaticMethod() const
    {
        void* result;
        check_hresult(WINRT_SHIM(Compare::IClassStatics)->StaticMethod(&result));
        return { construct_from_abi, result };
    }
    template <typename D> hstring consume_Compare_Class<D>::Method(Compare::Class const& winrt_impl_this) const
    {
        void* result;
        check_hresult(WINRT_SHIM(fast_factory<Compare::Class>)->Method(get_abi(winrt_impl_this), &result));
        return { construct_from_abi, result };
    }
    template <typename D> Compare::Class consume_Compare_Class<D>::CreateInstance(param::hstring const& a) const
    {
        void* value;
        check_hresult(WINRT_SHIM(fast_factory<Compare::Class>)->CreateInstance(get_abi(a), &value));
        return { construct_from_abi, value };
    }
    template <typename D> hstring consume_Compare_Class<D>::StaticMethod() const
    {
        void* result;
        check_hresult(WINRT_SHIM(fast_factory<Compare::Class>)->StaticMethod(&result));
        return { construct_from_abi, result };
    }
    template <> struct delegate<Compare::Delegate>
    {
        template <typename H>
        struct type : implements_delegate<Compare::Delegate, H>
        {
            type(H&& handler) : implements_delegate<Compare::Delegate, H>(std::forward<H>(handler)) {}

            int32_t WINRT_CALL Invoke(void* arg) noexcept final
            {
                try
                {
                    (*this)(*reinterpret_cast<hstring const*>(&arg));
                    return 0;
                }
                catch (...)
                {
                    return to_hresult();
                }
            }
        };
    };
    template <typename D>
    struct produce<D, Compare::IClass> : produce_base<D, Compare::IClass>
    {
        int32_t WINRT_CALL Method(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Method, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().Method());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, Compare::IClassFactory> : produce_base<D, Compare::IClassFactory>
    {
        int32_t WINRT_CALL CreateInstance(void* a, void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(Compare::Class), hstring const&);
                *value = detach_from<Compare::Class>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&a)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, Compare::IClassStatics> : produce_base<D, Compare::IClassStatics>
    {
        int32_t WINRT_CALL StaticMethod(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(StaticMethod, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().StaticMethod());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
    template <typename D>
    struct produce<D, fast_factory<Compare::Class>> : produce_base<D, fast_factory<Compare::Class>>
    {
        int32_t WINRT_CALL ActivateInstance(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(ActivateInstance, WINRT_WRAP(Compare::Class));
                *result = detach_abi(this->shim().ActivateInstance());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL Method(void* winrt_impl_this, void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(Method, WINRT_WRAP(hstring), Compare::Class const&);
                *result = detach_from<hstring>(this->shim().Method(*reinterpret_cast<Compare::Class const*>(&winrt_impl_this)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL CreateInstance(void* a, void** value) noexcept final
        {
            try
            {
                *value = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(Compare::Class), hstring const&);
                *value = detach_from<Compare::Class>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&a)));
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
        int32_t WINRT_CALL StaticMethod(void** result) noexcept final
        {
            try
            {
                *result = nullptr;
                typename D::abi_guard guard(this->shim());
                WINRT_ASSERT_DECLARATION(StaticMethod, WINRT_WRAP(hstring));
                *result = detach_from<hstring>(this->shim().StaticMethod());
                return 0;
            }
            catch (...) { return to_hresult(); }
        }
    };
}
namespace winrt::Compare
{
    template <typename L> Delegate::Delegate(L handler) :
        Delegate(impl::make_delegate<Delegate>(std::forward<L>(handler)))
    {}

    template <typename F> Delegate::Delegate(F* handler) :
        Delegate([=](auto&&... args) { return handler(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(O* object, M method) :
        Delegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(com_ptr<O>&& object, M method) :
        Delegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {}

    template <typename O, typename M> Delegate::Delegate(weak_ref<O>&& object, M method) :
        Delegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {}

    inline void Delegate::operator()(param::hstring const& arg) const
    {
        check_hresult((*(impl::abi_t<Delegate>**)this)->Invoke(get_abi(arg)));
    }
}
namespace std
{
    template<> struct hash<winrt::Compare::IClass> : winrt::impl::hash_base<winrt::Compare::IClass> {};
    template<> struct hash<winrt::Compare::IClassFactory> : winrt::impl::hash_base<winrt::Compare::IClassFactory> {};
    template<> struct hash<winrt::Compare::IClassStatics> : winrt::impl::hash_base<winrt::Compare::IClassStatics> {};
    template<> struct hash<winrt::Compare::Class> : winrt::impl::hash_base<winrt::Compare::Class> {};
}
