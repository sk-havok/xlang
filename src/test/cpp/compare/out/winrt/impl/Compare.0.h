// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.000000.0
#pragma once
#include "winrt/base.h"
namespace winrt::Compare
{
    struct IClass;
    struct IClassFactory;
    struct IClassStatics;
    struct Class;
    struct Delegate;
}
namespace winrt::impl
{
    template <> struct category<Compare::IClass>
    {
        using type = interface_category;
    };
    template <> struct category<Compare::IClassFactory>
    {
        using type = interface_category;
    };
    template <> struct category<Compare::IClassStatics>
    {
        using type = interface_category;
    };
    template <> struct category<Compare::Class>
    {
        using type = class_category;
    };
    template <> struct category<Compare::Delegate>
    {
        using type = delegate_category;
    };
    template <> struct name<Compare::IClass>
    {
        static constexpr auto & value{ L"Compare.IClass" };
    };
    template <> struct name<Compare::IClassFactory>
    {
        static constexpr auto & value{ L"Compare.IClassFactory" };
    };
    template <> struct name<Compare::IClassStatics>
    {
        static constexpr auto & value{ L"Compare.IClassStatics" };
    };
    template <> struct name<Compare::Class>
    {
        static constexpr auto & value{ L"Compare.Class" };
    };
    template <> struct name<Compare::Delegate>
    {
        static constexpr auto & value{ L"Compare.Delegate" };
    };
    template <> struct guid_storage<Compare::IClass>
    {
        static constexpr guid value{ 0xD207ED9C,0xB604,0x5842,{ 0xA6,0x32,0xA3,0x5B,0xA0,0x49,0x17,0x1F } };
    };
    template <> struct guid_storage<Compare::IClassFactory>
    {
        static constexpr guid value{ 0x6C228BFF,0xE9C7,0x5AF6,{ 0xBF,0x88,0xE2,0xB3,0xE8,0xCC,0x7C,0x2C } };
    };
    template <> struct guid_storage<Compare::IClassStatics>
    {
        static constexpr guid value{ 0x41768017,0x1D52,0x5B80,{ 0x94,0x66,0x84,0x50,0xA4,0x75,0x61,0xD8 } };
    };
    template <> struct guid_storage<Compare::Delegate>
    {
        static constexpr guid value{ 0x0E7304DC,0x4876,0x5729,{ 0x9F,0x86,0x4C,0xF7,0x52,0xF6,0xAA,0x2C } };
    };
    template <> struct default_interface<Compare::Class>
    {
        using type = Compare::IClass;
    };
    template <> struct abi<Compare::IClass>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL Method(void**) noexcept = 0;
        };
    };
    template <> struct abi<Compare::IClassFactory>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL CreateInstance(void*, void**) noexcept = 0;
        };
    };
    template <> struct abi<Compare::IClassStatics>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL StaticMethod(void**) noexcept = 0;
        };
    };
    template <> struct abi<Compare::Delegate>
    {
        struct type : unknown_abi
        {
            virtual int32_t WINRT_CALL Invoke(void*) noexcept = 0;
        };
    };
    template <> struct abi<fast_factory<Compare::Class>>
    {
        struct type : inspectable_abi
        {
            virtual int32_t WINRT_CALL ActivateInstance(void**) noexcept = 0;
            virtual int32_t WINRT_CALL Method(void*, void**) noexcept = 0;
            virtual int32_t WINRT_CALL CreateInstance(void*, void**) noexcept = 0;
            virtual int32_t WINRT_CALL StaticMethod(void**) noexcept = 0;
        };
    };
    template <typename D>
    struct consume_Compare_IClass
    {
        hstring Method() const;
    };
    template <> struct consume<Compare::IClass>
    {
        template <typename D> using type = consume_Compare_IClass<D>;
    };
    template <typename D>
    struct consume_Compare_IClassFactory
    {
        Compare::Class CreateInstance(param::hstring const& a) const;
    };
    template <> struct consume<Compare::IClassFactory>
    {
        template <typename D> using type = consume_Compare_IClassFactory<D>;
    };
    template <typename D>
    struct consume_Compare_IClassStatics
    {
        hstring StaticMethod() const;
    };
    template <> struct consume<Compare::IClassStatics>
    {
        template <typename D> using type = consume_Compare_IClassStatics<D>;
    };
    template <typename D>
    struct consume_Compare_Class
    {
        hstring Method(Compare::Class const&) const;
        Compare::Class CreateInstance(param::hstring const& a) const;
        hstring StaticMethod() const;
    };
    template <> struct consume<fast_factory<Compare::Class>>
    {
        template <typename D> using type = consume_Compare_Class<D>;
    };
}
